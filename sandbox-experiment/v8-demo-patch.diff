diff --git a/src/init/v8.cc b/src/init/v8.cc
index fbf120b1b6..6bef7460c9 100644
--- a/src/init/v8.cc
+++ b/src/init/v8.cc
@@ -4,6 +4,18 @@
 
 #include "src/init/v8.h"
 
+// start vv8 sandy experiment
+// --------------------
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+// --------------------
+// end vv8 sandy experiment
+
 #include <fstream>
 
 #include "include/cppgc/platform.h"
@@ -65,6 +77,106 @@ void V8::TearDown() {
   FlagList::ResetAllFlags();  // Frees memory held by string arguments.
 }
 
+// VV8 sandy logging experiment
+//-------------------------------------
+
+extern "C" int vv8_connect_to_logging_server(void) __attribute__((weak));
+
+static const char *ENV_VV8_LOG_HOST = "VV8_LOG_HOST";
+static const char *DEFAULT_VV8_LOG_HOST = "localhost";
+static const char *ENV_VV8_LOG_PORT = "VV8_LOG_PORT";
+static const char *DEFAULT_VV8_LOG_PORT = "5580";
+
+static int
+vv8_connect_to_logging_server_direct() {
+  int ret = -1;
+  const char *log_host = NULL;
+  const char *log_port = NULL;
+  struct addrinfo hints;
+  struct addrinfo *result = NULL, *rp;
+  int sfd, s;
+
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = AF_UNSPEC;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = 0;
+  hints.ai_protocol = 0;
+
+  if ((log_host = getenv(ENV_VV8_LOG_HOST)) == NULL) {
+    log_host = DEFAULT_VV8_LOG_HOST;	
+  }
+  if ((log_port = getenv(ENV_VV8_LOG_PORT)) == NULL) {
+    log_port = DEFAULT_VV8_LOG_PORT;
+  }
+  printf("debug: connecting to %s:%s\n", log_host, log_port);
+
+  s = getaddrinfo(log_host, log_port, &hints, &result);
+  if (s != 0) {
+    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
+    goto cleanup;
+  }
+  for (rp = result; rp != NULL; rp = rp->ai_next) {
+    sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
+    if (sfd < 0) continue;
+    if (connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1) break;
+    close(sfd);
+  }
+  if (rp == NULL) {
+    fprintf(stderr, "could not connect to %s:%s\n", log_host, log_port);
+    goto cleanup;
+  }
+
+  ret = sfd;
+cleanup:
+  if (result != NULL) {
+    freeaddrinfo(result);
+  }
+  return ret;
+}
+
+void vv8_logging_test() {
+  char buf[512], *bp;
+  size_t left;
+  ssize_t sent;
+  int sock = -1;
+
+
+  if ((sock = vv8_connect_to_logging_server_direct()) < 0) {
+    fprintf(stderr, "VV8: unable to connect to log server directly (%d)...\n", sock);
+    if (vv8_connect_to_logging_server) {
+      fprintf(stderr, "VV8: connecting via IPC...\n");
+      sock = vv8_connect_to_logging_server();
+    } else {
+      fprintf(stderr, "VV8: IPC connection symbol not linked; aborting...\n");
+    }
+  }
+
+  if (sock < 0) {
+    fprintf(stderr, "unable to connect to VV8 log server\n");
+    goto cleanup;
+  }
+
+  snprintf(buf, sizeof(buf), "hello from pid=%d, tid=%d\n",
+      base::OS::GetCurrentProcessId(),
+      base::OS::GetCurrentThreadId());
+  left = strlen(buf);
+  bp = buf;
+  while (left > 0) {
+    if ((sent = send(sock, bp, left, 0)) < 0) {
+      perror("send");
+      goto cleanup;
+    }
+    left -= sent;
+    bp += sent;
+  }
+cleanup:
+  if (sock >= 0) {
+    if (shutdown(sock, SHUT_RDWR)) perror("shutdown");
+    if (close(sock)) perror("close");
+    sock = -1;
+  }
+}
+
 void V8::InitializeOncePerProcessImpl() {
   // Update logging information before enforcing flag implications.
   bool* log_all_flags[] = {&FLAG_turbo_profiling_log_builtins,
@@ -163,6 +275,9 @@ void V8::InitializeOncePerProcessImpl() {
 #if V8_ENABLE_WEBASSEMBLY
   wasm::WasmEngine::InitializeOncePerProcess();
 #endif  // V8_ENABLE_WEBASSEMBLY
+
+  // sandVV8 experiment: try to connect to the logging socket
+  vv8_logging_test();    
 }
 
 void V8::InitializeOncePerProcess() {
